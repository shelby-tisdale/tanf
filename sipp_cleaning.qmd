```{r}
#| label: load-packages
#| message: false
#| warning: false

# load packages
library(tidyverse)
library(data.table)
library(bit64)
library(janitor)

```

```{r}
#| label: load-tanf-data

# load federal tanf data
tanf <- read_csv("data/total_expenditures_2015_2022.csv")

# create dataset of state-year-level tanf data
tanf_state_year <- tanf |>
  # filter for relevant years
  filter(fiscal_year %in% c(2018:2022)) |>
  # create variables for percent unobligated funds, percent spent on basic
  # assistance, and percent spent on program management
  mutate(pct_unobligated = unobligated_balance/(funds_awarded + carryover),
         pct_basic_assistance = basic_assistance/total_expenditures,
         pct_program_mgmt = program_mgmt/total_expenditures) |>
  # select relevant variables
  select(state, fiscal_year, pct_unobligated, pct_program_mgmt, pct_basic_assistance)

```


```{r}
# create function for loading data
load_sipp <- function(directory) {
  ds <- c(directory)
  sipp <- fread(ds, sep = "|", select = c(
    # ID VARS
   "SHHADID", "SPANEL", "SSUID", "SWAVE", "PNUM", "MONTHCODE", "GHLFSAM",
   "EHRESIDENCID", "EINTTYPE", "ERESIDENCEID","RIN_UNIV",
   "THHLDSTATUS", "TST_INTV", "EPNPAR1", "EPNPAR2", "EPNCOHAB", "EPNSPOUSE",
   "RPNCHILD1", "RPNCHILD2", "RPNCHILD3", "RPNCHILD4", "RPNCHILD5", "RPNCHILD6",
   "RPNCHILD7", "RPNCHILD8", "RPNCHILD9", "RPNCHILD10", "RPNCHILD11",
   "RPNCHILD12",
    # WEIGHTS AND SAMPLING
   "GVARSTR", "WPFINWGT",
   # OTHER
   "EANYKID", "EBDAD", "EBMOM", "ECLTH_SR1YN", "EJB1_BSLRYB", "EJB1_SCRNR",
   "EMPF", "EMS_EHC", "ENJ_LKWRK", "ENJFLAG", "EPAR_SCRNR", "EPAR1TYP",
   "EPAR2TYP", "ERELRPE", "ETANF_BMONTH", "ETANF_COVTYP", "ETANF_EMONTH",
   "ETANF_OWN", "ETANF_PTCS", "EWELAC_MNYN", "EWELACTV1", "EWELACTV2_1",
   "EWELACTV2_2", "EWELACTV2_3", "EWELACTV4", "EXMAR", "RCB_UNION", "RCHTYP1",
   "RCHTYP2", "RCHTYP3", "RCHTYP4","RCHTYP5", "RCHTYP6", "RCHTYP7","RCHTYP8",
   "RCHTYP9", "RCHTYP10", "RCHTYP11", "RCHTYP12", "RSNAP_YRYN", "RTANF_CFLG",
   "RTANF_LCYR", "RTANF_MNYN", "RTANF_YRYN", "RWIC_YRYN", "TAGE", "TAGE_FB",
   "TCEB", "TFCYINCPOV", "TFINCPOV", "THINCPOV", "TNUM_CBU", "TNUMKIDS",
   "TPTRNINC", "TTANF_AMT", "TTANF_BRSN", "TTANF_ERSN", "TYEAR_FB", "ERP",
   "RFAMNUM", "RFPERSONS",
   # RELATIONSHIP DATA
   "RREL1", "RREL2", "RREL3", "RREL4", "RREL5", "RREL6", "RREL7", "RREL8",
   "RREL9", "RREL10", "RREL11", "RREL12", "RREL13", "RREL14", "RREL15",
   "RREL16", "RREL17", "RREL18", "RREL19", "RREL20", "RREL21", "RREL22",
   "RREL23", "RREL24", "RREL25", "RREL26", "RREL27", "RREL28", "RREL29",
   "RREL30", "RREL_PNUM1", "RREL_PNUM2", "RREL_PNUM3", "RREL_PNUM4",
   "RREL_PNUM5", "RREL_PNUM6", "RREL_PNUM7", "RREL_PNUM8", "RREL_PNUM9",
   "RREL_PNUM10", "RREL_PNUM11", "RREL_PNUM12", "RREL_PNUM13", "RREL_PNUM14",
   "RREL_PNUM15", "RREL_PNUM16", "RREL_PNUM17", "RREL_PNUM18", "RREL_PNUM19",
   "RREL_PNUM20", "RREL_PNUM21", "RREL_PNUM22", "RREL_PNUM23", "RREL_PNUM24",
   "RREL_PNUM25", "RREL_PNUM26", "RREL_PNUM27", "RREL_PNUM28", "RREL_PNUM29",
   "RREL_PNUM30"
  ))
  names(sipp) <- toupper(names(sipp))
  return(sipp)
}
# load survey data for each year
sipp2022 <- load_sipp("data/sipp/pu2022.csv") |>
  mutate(year = 2022)
sipp2021 <- load_sipp("data/sipp/pu2021.csv") |>
  mutate(year = 2021)
sipp2020 <- load_sipp("data/sipp/pu2020.csv") |>
  mutate(year = 2020)
sipp2019 <- load_sipp("data/sipp/pu2019.csv") |>
  mutate(year = 2019)
sipp2018 <- load_sipp("data/sipp/pu2018.csv") |>
  mutate(year = 2018)

# combine data frames
sipp <- rbind.data.frame(sipp2022, sipp2021, sipp2020, sipp2019, sipp2018) |>
  clean_names()

# download csv
#write.csv(sipp, "sipp.csv")
```

```{r}
#| label: rename-columns

sipp <- sipp |>
  rename(
    hh_address_id = shhadid,
    panel_year = spanel,
    sample_unit_id = ssuid,
    wave_num = swave,
    person_num = pnum,
    month = monthcode,
    half_sample_code = ghlfsam,
    var_strat_code = gvarstr,
    person_weight = wpfinwgt,
    interview_address_id = ehresidencid,
    residence_address_id = eresidenceid,
    in_universe = rin_univ,
    hh_status = thhldstatus,
    state = tst_intv,
    age = tage,
    parent1_num = epnpar1,
    parent2_num = epnpar2,
    reference_par = erp,
    spouse_num = epnspouse,
    unmarried_partner_num = epncohab,
    num_children = tceb,
    num_children_elsewhere = tnumkids,
    child1_num = rpnchild1,
    child2_num = rpnchild2,
    child3_num = rpnchild3,
    child4_num = rpnchild4,
    child5_num = rpnchild5,
    child6_num = rpnchild6,
    child7_num = rpnchild7,
    child8_num = rpnchild8,
    child9_num = rpnchild9,
    child10_num = rpnchild10,
    child11_num = rpnchild11,
    child12_num = rpnchild12,
    other_kids = eanykid,
    age_first_birth = tage_fb,
    year_first_birth = tyear_fb,
    father_mortality = ebdad,
    mother_mortality = ebmom,
    govt_assistance = eclth_sr1yn,
    reg_salary = ejb1_bslryb,
    has_job = ejb1_scrnr,
    children_mult_partners = empf,
    marital_status = ems_ehc,
    look_for_work = enj_lkwrk,
    no_job_spell = enjflag,
    is_parent = epar_scrnr,
    parent1_type = epar1typ,
    parent2_type = epar2typ,
    hh_relationship = erelrpe,
    tanf_begin_month = etanf_bmonth,
    tanf_begin_year = rtanf_lcyr,
    tanf_end_month = etanf_emonth,
    tanf_coverage_type = etanf_covtyp,
    tanf_owner = etanf_own,
    tanf_child_support = etanf_ptcs,
    tanf_continue = rtanf_cflg,
    tanf_received_month = rtanf_mnyn,
    tanf_received_year = rtanf_yryn,
    tanf_amt_month = ttanf_amt,
    tanf_begin_reason = ttanf_brsn,
    tanf_end_reason = ttanf_ersn,
    wic_received_year = rwic_yryn,
    job_training_month = ewelac_mnyn,
    reading_math_class = ewelactv1,
    job_readiness_training = ewelactv2_1,
    job_search_program = ewelactv2_2,
    job_skill_training = ewelactv2_3,
    work_for_tanf = ewelactv4,
    times_married = exmar,
    childbearing_union = rcb_union,
    num_childbearing_union = tnum_cbu,
    received_snap = rsnap_yryn,
    year_family_inc_pov_ = tfcyincpov,
    month_family_inc_pov = tfincpov,
    month_hh_inc_pov = thincpov,
    govt_income_monthly = tptrninc
    )

sipp <- sipp |>
  mutate(state = case_match(
    state,
    1 ~ "ALABAMA",
    2 ~ "ALASKA", 
    4 ~ "ARIZONA",
    5 ~ "ARKANSAS",
    6 ~ "CALIFORNIA",
    8 ~ "COLORADO",
    9 ~ "CONNECTICUT",
    10 ~ "DELAWARE",
    11 ~ "DIST.OF COLUMBIA",
    12 ~ "FLORIDA",
    13 ~ "GEORGIA",
    15 ~ "HAWAII",
    16 ~ "IDAHO",
    17 ~ "ILLINOIS",
    18 ~ "INDIANA",
    19 ~ "IOWA",
    20 ~ "KANSAS",
    21 ~ "KENTUCKY",
    22 ~ "LOUISIANA",
    23 ~ "MAINE",
    24 ~ "MARYLAND",
    25 ~ "MASSACHUSETTS",
    26 ~ "MICHIGAN",
    27 ~ "MINNESOTA",
    28 ~ "MISSISSIPPI",
    29 ~ "MISSOURI",
    30 ~ "MONTANA",
    31 ~ "NEBRASKA",
    32 ~ "NEVADA",
    33 ~ "NEW HAMPSHIRE",
    34 ~ "NEW JERSEY",
    35 ~ "NEW MEXICO",
    36 ~ "NEW YORK",
    37 ~ "NORTH CAROLINA",
    38 ~ "NORTH DAKOTA",
    39 ~ "OHIO",
    40 ~ "OKLAHOMA",
    41 ~ "OREGON",
    42 ~ "PENNSYLVANIA",
    44 ~ "RHODE ISLAND",
    45 ~ "SOUTH CAROLINA",
    46 ~ "SOUTH DAKOTA",
    47 ~ "TENNESSEE",
    48 ~ "TEXAS",
    49 ~ "UTAH",
    50 ~ "VERMONT",
    51 ~ "VIRGINIA",
    53 ~ "WASHINGTON",
    54 ~ "WEST VIRGINIA",
    55 ~ "WISCONSIN",
    56 ~ "WYOMING",
    60 ~ "PUERTO RICO AND ISLAND AREAS",
    61 ~ "FOREIGN COUNTRY",
    .default = as.character(state)
    )) |>
  filter(!is.na(state))

# load new data
#sipp <- read.csv("data/sipp.csv")
```

```{r}
#| label: all-participants
#| warning: false

# find households that have at least one child in any month
households_with_children <- sipp |>
  # sample unit id is originally sampled household
  # interview address id is residence where interview is conducted
  # household_address id differentiates parent from spawned households
  # residence address id is current residence for each month
  # what should be used as unique identifier for address?
  group_by(sample_unit_id, year, month, state) |>
  # count number of children in each household
  summarize(hh_children_count = sum(age < 18, na.rm = TRUE), .groups = "drop") |>
  # remove households without children
  filter(hh_children_count != 0) |>
  # select distinct households
  select(sample_unit_id, year, month, state) |>
  filter(!is.na(state)) |>
  distinct()

# determine quantiles of monthly household income-to-poverty ratio
# what income cutoff should I use?
# find tanf eligible incomes
# look into government income cutoffs - how to quantify low-income
inc_pov_quantiles <- quantile(sipp$month_hh_inc_pov, na.rm = TRUE)

# select low-income households
household_poverty <- sipp |>
  group_by(sample_unit_id, interview_address_id, residence_address_id,
           hh_address_id, year, month, state) |>
  summarise(low_income = if_else(month_hh_inc_pov <= inc_pov_quantiles[3], 1, 0)) |>
  filter(low_income == 1) |>
  distinct()


# create dataset with only households with children
# that at some point are low-income
# difference between amount of records in this dataset and records in initial
# dataset is quite small
sipp_participants <- sipp |>
  filter(sample_unit_id %in% households_with_children$sample_unit_id &
         sample_unit_id %in% household_poverty$sample_unit_id)
```

```{r}
#| label: data-for-tanf-goal-one

# reference parents and children

# household relationship approach
# first looks at whether the child has parents in the household
# then uses householder relationship variable to determine whether they live
# with relatives
children <- sipp_participants |>
  # filters participants for children only
  mutate(is_child = if_else(age < 18, 1, 0)) |>
  filter(is_child == 1) |>
  # select relevant variables
  select(
    year, month, state, sample_unit_id, interview_address_id, residence_address_id,
    hh_address_id, person_num, age, hh_relationship, parent1_num, parent2_num,
    rfpersons, is_parent) |>
  # goal1 = 1 if goal fulfilled (by child and month), goal1 = 0 if not
  mutate(goal1 = case_when(
    # child who has at least one parent in household
    !is.na(parent1_num) | !is.na(parent2_num) ~ 1,
    # child who is only person in family
    #rfpersons == 1 ~ 0,
    # householder with relatives
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 1 ~ 1,
    # householder no relatives
    #is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 2 ~ 0,
    # foster child
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 15 ~ 0,
    # grandchild
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 8 ~ 1,
    # sibling
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 10 ~ 1,
    # niece / nephew
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 13 ~ 1,
    # other relative
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 14 ~ 1,
    # unmarried partner
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 4 ~ 0,
    # other nonrelative
    #is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 18 ~ 0,
    # brother/sister-in-law
    #is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 12 ~ 1
  ))

# there are three children where household relationship is parent/child-in-law??
#children |>
 # filter(is.na(goal1))


# lookup table approach
# create table of reference parents, all children, and their relationships
parent_child_lookup <- sipp_participants |>
  # filters for only people who identify as reference parents
  filter(reference_par == 1) |>
  # parent person number and sample unit id (id vars)
  # child variables and relationship variables
  select(person_num, sample_unit_id, month, year, starts_with("child"),
         starts_with("rrel")) |>
  select(-c(children_mult_partners, childbearing_union)) |>
  # each row is a unique parent-child combination for a month
  pivot_longer(cols = starts_with("child"),
               names_to = "child",
               values_to = "child_person_number") |>
  filter(!is.na(child_person_number)) |>
  distinct() |>
  # each row is a parent-child combination for a month, repeated for
  # person numbers of all other members of the household
  pivot_longer(cols = starts_with("rrel_pnum"),
               names_to = "hh_member_number",
               values_to = "person_num_rel") |>
  filter(!is.na(person_num_rel)) |>
  distinct() |>
  # each row is a parent-child combination for a month, repeated for the
  # person number and relationship to all other members of household
  pivot_longer(cols = starts_with("rrel"),
               names_to = "hh_member_number2",
               values_to = "relationship") |>
  filter(!is.na(relationship)) |>
  distinct() |>
  # remove relationships for individuals who are not the child of the reference
  # parent
  filter(person_num_rel == child_person_number) |>
  distinct() |>
  # match household member numbers for relationship and person number variables
  mutate(hh_member_number = parse_number(hh_member_number),
         hh_member_number2 = parse_number(hh_member_number2)) |>
  filter(hh_member_number == hh_member_number2) |>
  distinct() |>
  # select relevant variables for parent-child lookup
  select(sample_unit_id, year, month, person_num, child_person_number,
         relationship) |>
  rename(ref_parent_person_num = person_num, child_person_num = child_person_number)

# evaluates whether tanf goal 1 is achieved for a household in a given year and month
hh_goal1 <- children |>
  # group by year, mont, and household
  group_by(year, month, state, sample_unit_id) |>
  # determine average (over all children in household in that month)
  # achievement of goal 1
  summarise(avg_goal1 = mean(goal1, na.rm = TRUE), .groups = "drop") |>
  # if goal1 = 0 for any child in household, goal1 is not achieved
  mutate(hh_month_goal1 = if_else(avg_goal1 != 1, 0, 1))


hh_goal1 |>
  count(hh_month_goal1)


# make lookup tables for fringe cases
# next steps
# bring in household demographic data
# bring in predictor variables

```

```{r}
#| label: join-goal1-to-tanf-data
```

