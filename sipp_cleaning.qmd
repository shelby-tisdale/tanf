---
title: "SIPP Data Cleaning"
author: "Shelby Tisdale"
format: html
---

# Load Data and Packages

```{r}
#| label: load-packages
#| message: false
#| warning: false

# load packages
library(tidyverse)
library(data.table)
library(bit64)
library(janitor)

```

```{r}
#| label: load-tanf-data
#| message: false

# load federal tanf data
tanf <- read_csv("data/total_expenditures_2015_2022.csv")

# creates dataset of relevant state-year-level tanf predictors 2018-2022
tanf_state_year <- tanf |>
  # filter for relevant years
  filter(fiscal_year %in% c(2018:2022)) |>
  # create variables for percent unobligated funds, percent spent on basic
  # assistance, and percent spent on program management
  mutate(pct_unobligated = unobligated_balance/(funds_awarded + carryover),
         pct_basic_assistance = basic_assistance/total_expenditures,
         pct_program_mgmt = program_mgmt/total_expenditures) |>
  # select relevant variables
  select(state, fiscal_year, pct_unobligated, pct_program_mgmt,
         pct_basic_assistance)
```

```{r}
# create function for loading data
load_sipp <- function(directory) {
  ds <- c(directory)
  sipp <- fread(ds, sep = "|", select = c(
    # ID VARS
   "SHHADID", "SPANEL", "SSUID", "SWAVE", "PNUM", "MONTHCODE", "GHLFSAM",
   "EHRESIDENCID", "EINTTYPE", "ERESIDENCEID","RIN_UNIV",
   "THHLDSTATUS", "TST_INTV", "EPNPAR1", "EPNPAR2", "EPNCOHAB", "EPNSPOUSE",
   "RPNCHILD1", "RPNCHILD2", "RPNCHILD3", "RPNCHILD4", "RPNCHILD5", "RPNCHILD6",
   "RPNCHILD7", "RPNCHILD8", "RPNCHILD9", "RPNCHILD10", "RPNCHILD11",
   "RPNCHILD12",
    # WEIGHTS AND SAMPLING
   "GVARSTR", "WPFINWGT",
   # OTHER
   "EANYKID", "EBDAD", "EBMOM", "ECLTH_SR1YN", "EJB1_BSLRYB", "EJB1_SCRNR",
   "EMPF", "EMS_EHC", "ENJ_LKWRK", "ENJFLAG", "EPAR_SCRNR", "EPAR1TYP",
   "EPAR2TYP", "ERELRPE", "ETANF_BMONTH", "ETANF_COVTYP", "ETANF_EMONTH",
   "ETANF_OWN", "ETANF_PTCS", "EWELAC_MNYN", "EWELACTV1", "EWELACTV2_1",
   "EWELACTV2_2", "EWELACTV2_3", "EWELACTV4", "EXMAR", "RCB_UNION", "RCHTYP1",
   "RCHTYP2", "RCHTYP3", "RCHTYP4","RCHTYP5", "RCHTYP6", "RCHTYP7","RCHTYP8",
   "RCHTYP9", "RCHTYP10", "RCHTYP11", "RCHTYP12", "RSNAP_YRYN", "RTANF_CFLG",
   "RTANF_LCYR", "RTANF_MNYN", "RGA_YRYN", "RTANF_YRYN", "RWIC_YRYN", "TAGE",
   "TAGE_FB", "EUC1MNYN",
   "TCEB", "TFCYINCPOV", "TFINCPOV", "THINCPOV", "TNUM_CBU", "TNUMKIDS",
   "TPTRNINC", "TTANF_AMT", "TTANF_BRSN", "TTANF_ERSN", "TYEAR_FB", "ERP",
   "RFAMNUM", "RFPERSONS",
   # DEMOGRAPHICS
   "EEDUC", "EORIGIN", "TRACE", "ESEX", "RAFEVER", "ECITIZEN",
   # RELATIONSHIP DATA
   "RREL1", "RREL2", "RREL3", "RREL4", "RREL5", "RREL6", "RREL7", "RREL8",
   "RREL9", "RREL10", "RREL11", "RREL12", "RREL13", "RREL14", "RREL15",
   "RREL16", "RREL17", "RREL18", "RREL19", "RREL20", "RREL21", "RREL22",
   "RREL23", "RREL24", "RREL25", "RREL26", "RREL27", "RREL28", "RREL29",
   "RREL30", "RREL_PNUM1", "RREL_PNUM2", "RREL_PNUM3", "RREL_PNUM4",
   "RREL_PNUM5", "RREL_PNUM6", "RREL_PNUM7", "RREL_PNUM8", "RREL_PNUM9",
   "RREL_PNUM10", "RREL_PNUM11", "RREL_PNUM12", "RREL_PNUM13", "RREL_PNUM14",
   "RREL_PNUM15", "RREL_PNUM16", "RREL_PNUM17", "RREL_PNUM18", "RREL_PNUM19",
   "RREL_PNUM20", "RREL_PNUM21", "RREL_PNUM22", "RREL_PNUM23", "RREL_PNUM24",
   "RREL_PNUM25", "RREL_PNUM26", "RREL_PNUM27", "RREL_PNUM28", "RREL_PNUM29",
   "RREL_PNUM30",
   # CHILD BIRTH YEARS
   "TCBYR_1", "TCBYR_2", "TCBYR_3", "TCBYR_4", "TCBYR_5", "TCBYR_6", "TCBYR_7"
  ))
  names(sipp) <- toupper(names(sipp))
  return(sipp)
}
# load survey data for each year
sipp2022 <- load_sipp("data/sipp/pu2022.csv") |>
  mutate(year = 2022)
sipp2021 <- load_sipp("data/sipp/pu2021.csv") |>
  mutate(year = 2021)
sipp2020 <- load_sipp("data/sipp/pu2020.csv") |>
  mutate(year = 2020)
sipp2019 <- load_sipp("data/sipp/pu2019.csv") |>
  mutate(year = 2019)
sipp2018 <- load_sipp("data/sipp/pu2018.csv") |>
  mutate(year = 2018)

# combine data frames
sipp <- rbind.data.frame(sipp2022, sipp2021, sipp2020, sipp2019, sipp2018) |>
  clean_names()

# download csv
# write.csv(sipp, "sipp.csv")
```

# Rename Variables

```{r}
#| label: rename-columns

# rename variables to understandable names
sipp <- sipp |>
  rename(
    hh_address_id = shhadid,
    panel_year = spanel,
    sample_unit_id = ssuid,
    wave_num = swave,
    person_num = pnum,
    month = monthcode,
    half_sample_code = ghlfsam,
    var_strat_code = gvarstr,
    person_weight = wpfinwgt,
    interview_address_id = ehresidencid,
    residence_address_id = eresidenceid,
    in_universe = rin_univ,
    hh_status = thhldstatus,
    state = tst_intv,
    age = tage,
    parent1_num = epnpar1,
    parent2_num = epnpar2,
    reference_par = erp,
    spouse_num = epnspouse,
    unmarried_partner_num = epncohab,
    num_children = tceb,
    num_children_elsewhere = tnumkids,
    child1_num = rpnchild1,
    child2_num = rpnchild2,
    child3_num = rpnchild3,
    child4_num = rpnchild4,
    child5_num = rpnchild5,
    child6_num = rpnchild6,
    child7_num = rpnchild7,
    child8_num = rpnchild8,
    child9_num = rpnchild9,
    child10_num = rpnchild10,
    child11_num = rpnchild11,
    child12_num = rpnchild12,
    other_kids = eanykid,
    age_first_birth = tage_fb,
    year_first_birth = tyear_fb,
    father_mortality = ebdad,
    mother_mortality = ebmom,
    govt_assistance = eclth_sr1yn,
    reg_salary = ejb1_bslryb,
    has_job = ejb1_scrnr,
    children_mult_partners = empf,
    marital_status = ems_ehc,
    look_for_work = enj_lkwrk,
    no_job_spell = enjflag,
    is_parent = epar_scrnr,
    parent1_type = epar1typ,
    parent2_type = epar2typ,
    hh_relationship = erelrpe,
    tanf_begin_month = etanf_bmonth,
    tanf_begin_year = rtanf_lcyr,
    tanf_end_month = etanf_emonth,
    tanf_coverage_type = etanf_covtyp,
    tanf_owner = etanf_own,
    tanf_child_support = etanf_ptcs,
    tanf_continue = rtanf_cflg,
    tanf_received_month = rtanf_mnyn,
    tanf_received_year = rtanf_yryn,
    tanf_amt_month = ttanf_amt,
    tanf_begin_reason = ttanf_brsn,
    tanf_end_reason = ttanf_ersn,
    wic_received_year = rwic_yryn,
    job_training_month = ewelac_mnyn,
    reading_math_class = ewelactv1,
    job_readiness_training = ewelactv2_1,
    job_search_program = ewelactv2_2,
    job_skill_training = ewelactv2_3,
    work_for_tanf = ewelactv4,
    times_married = exmar,
    childbearing_union = rcb_union,
    num_childbearing_union = tnum_cbu,
    received_snap = rsnap_yryn,
    received_ga = rga_yryn,
    unemp_comp = euc1mnyn,
    year_family_inc_pov_ = tfcyincpov,
    month_family_inc_pov = tfincpov,
    month_hh_inc_pov = thincpov,
    govt_income_monthly = tptrninc,
    education = eeduc,
    ethnicity = eorigin,
    race = trace,
    sex = esex,
    veteran_status = rafever,
    citizenship = ecitizen
    )

# recode state names
sipp <- sipp |>
  mutate(state = case_match(
    state,
    1 ~ "ALABAMA",
    2 ~ "ALASKA", 
    4 ~ "ARIZONA",
    5 ~ "ARKANSAS",
    6 ~ "CALIFORNIA",
    8 ~ "COLORADO",
    9 ~ "CONNECTICUT",
    10 ~ "DELAWARE",
    11 ~ "DIST.OF COLUMBIA",
    12 ~ "FLORIDA",
    13 ~ "GEORGIA",
    15 ~ "HAWAII",
    16 ~ "IDAHO",
    17 ~ "ILLINOIS",
    18 ~ "INDIANA",
    19 ~ "IOWA",
    20 ~ "KANSAS",
    21 ~ "KENTUCKY",
    22 ~ "LOUISIANA",
    23 ~ "MAINE",
    24 ~ "MARYLAND",
    25 ~ "MASSACHUSETTS",
    26 ~ "MICHIGAN",
    27 ~ "MINNESOTA",
    28 ~ "MISSISSIPPI",
    29 ~ "MISSOURI",
    30 ~ "MONTANA",
    31 ~ "NEBRASKA",
    32 ~ "NEVADA",
    33 ~ "NEW HAMPSHIRE",
    34 ~ "NEW JERSEY",
    35 ~ "NEW MEXICO",
    36 ~ "NEW YORK",
    37 ~ "NORTH CAROLINA",
    38 ~ "NORTH DAKOTA",
    39 ~ "OHIO",
    40 ~ "OKLAHOMA",
    41 ~ "OREGON",
    42 ~ "PENNSYLVANIA",
    44 ~ "RHODE ISLAND",
    45 ~ "SOUTH CAROLINA",
    46 ~ "SOUTH DAKOTA",
    47 ~ "TENNESSEE",
    48 ~ "TEXAS",
    49 ~ "UTAH",
    50 ~ "VERMONT",
    51 ~ "VIRGINIA",
    53 ~ "WASHINGTON",
    54 ~ "WEST VIRGINIA",
    55 ~ "WISCONSIN",
    56 ~ "WYOMING",
    60 ~ "PUERTO RICO AND ISLAND AREAS",
    61 ~ "FOREIGN COUNTRY",
    .default = as.character(state)
    )) |>
  filter(!is.na(state))

# load new data
# sipp <- read.csv("data/sipp.csv")
```

# Filter Data for Relevant Participants

This dataset includes all low-income households that have at least one child in at least one month. Low-income households will be defined by looking at data on TANF eligibility by income and state. Households with TANF-eligible incomes will be included in the sample.

```{r}
#| label: all-participants
#| warning: false

# find households that have at least one child in any month
households_with_children <- sipp |>
  # sample unit id is originally sampled household
  # this will be used as the houshehold indicator
  group_by(sample_unit_id, year, month, state) |>
  # count number of children in each household
  summarize(hh_children_count = sum(age < 18, na.rm = TRUE),
            .groups = "drop") |>
  # remove households without children
  filter(hh_children_count != 0) |>
  # select distinct households
  select(sample_unit_id, year, month, state) |>
  filter(!is.na(state)) |>
  distinct()

# determine quantiles of monthly household income-to-poverty ratio
# what income cutoff should I use?
# find tanf eligible incomes
# look into government income cutoffs - how to quantify low-income
inc_pov_quantiles <- quantile(sipp$month_hh_inc_pov, na.rm = TRUE)

# select low-income households
#household_poverty <- sipp |>
 # group_by(sample_unit_id, interview_address_id, residence_address_id,
  #         hh_address_id, year, month, state) |>
  #summarise(low_income = if_else(month_hh_inc_pov <= inc_pov_quantiles[3], 1, 0),
  #          .groups = "drop") |>
  #filter(low_income == 1) |>
  #distinct()


# create dataset with only households with children
# that at some point are low-income
# difference between amount of records in this dataset and records in initial
# dataset is quite small
sipp_participants <- sipp |>
  filter(sample_unit_id %in% households_with_children$sample_unit_id) #&
         #sample_unit_id %in% household_poverty$sample_unit_id)


count(sipp_participants, state)
```

# Creating Variable for Achievement of TANF Goal 1

**Goal 1:** Provide assistance to needy families so that children can be cared for in their own homes or in the homes of relatives

**Criteria:** This goal is fulfilled for a given household and month if all children in the household have at least one relative in the household.

```{r}
#| label: data-for-tanf-goal-1

# household relationship approach
# first looks at whether the child has parents in the household
# then uses householder relationship variable to determine whether they live
# with relatives
children <- sipp_participants |>
  # filters participants for children only
  mutate(is_child = if_else(age < 18, 1, 0)) |>
  filter(is_child == 1) |>
  # select relevant variables
  select(
    year, month, state, sex, sample_unit_id, interview_address_id, residence_address_id,
    hh_address_id, person_num, age, hh_relationship, parent1_num, parent2_num,
    rfpersons, is_parent, starts_with("rrel")) |>
  # goal1 = 1 if goal fulfilled (by child and month), goal1 = 0 if not
  mutate(goal1 = case_when(
    # child who has at least one parent in household
    !is.na(parent1_num) | !is.na(parent2_num) ~ 1,
    # householder with relatives
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 1 ~ 1,
    # foster child
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 15 ~ 0,
    # grandchild
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 8 ~ 1,
    # sibling
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 10 ~ 1,
    # niece / nephew
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 13 ~ 1,
    # other relative
    is.na(parent1_num) & is.na(parent2_num) & hh_relationship == 14 ~ 1,
    # indicator for fringe cases
    .default = 2
  ))

# lookup table approach
# create table of fringe cases (children who do not have parents,
# relatives are not householders) and their relationships to other household members
children_lookup <- children |>
  # filter for fringe cases
  filter(goal1 == 2) |>
  mutate(child_person_num = person_num) |>
  # child person number and sample unit id (id vars)
  # relationship variables
  select(child_person_num, sample_unit_id, month, year, hh_relationship, starts_with("rrel"), goal1) |>
  # each row is a household member-child combination for a month, for
  # person numbers of all  members of the household
  pivot_longer(cols = starts_with("rrel_pnum"),
               names_to = "hh_member_number",
               values_to = "person_num_rel") |>
  filter(!is.na(person_num_rel)) |>
  distinct() |>
  # each row is a household member-child combination for a month, for the
  # person number and relationship to all members of household
  pivot_longer(cols = starts_with("rrel"),
               names_to = "hh_member_number2",
               values_to = "relationship") |>
  filter(!is.na(relationship)) |>
  distinct() |>
  # match household member numbers for relationship and person number variables
  mutate(hh_member_number = parse_number(hh_member_number),
         hh_member_number2 = parse_number(hh_member_number2)) |>
  filter(hh_member_number == hh_member_number2) |>
  distinct() |>
  filter(relationship != 99) |>
  # select relevant variables for lookup
  select(child_person_num, sample_unit_id, year, month, relationship, hh_relationship, goal1) |>
  distinct() |>
  # indicator for whether person is a relative of the child
  mutate(goal1 = if_else(relationship %in% c(5, 7, 8, 9, 10, 12, 16, 17), 1, 0)) |>
  group_by(year, month, sample_unit_id, child_person_num) |>
  # if average of relative indicators is greater than 0, child lives with at
  # least one relative
  summarize(goal1_avg = mean(goal1)) |>
  mutate(goal1 = if_else(goal1_avg == 0, 0, 1)) |>
  select(-c(goal1_avg))

# match children dataset to lookup table to update goal fulfilled for fringe cases
children <- children |>
  left_join(children_lookup, by = join_by("person_num" == "child_person_num", year, month, sample_unit_id)) |>
  select(year, month, state, sample_unit_id, hh_address_id, person_num, age, goal1.x, goal1.y) |>
  mutate(goal1 = if_else(goal1.x == 2, goal1.y, goal1.x)) |>
  select(-c(goal1.x, goal1.y))

# evaluates whether tanf goal 1 is achieved for a household in a given year and month
hh_goal1 <- children |>
  # group by year, mont, and household
  group_by(year, month, state, sample_unit_id) |>
  # determine average (over all children in household in that month)
  # achievement of goal 1
  summarise(avg_goal1 = mean(goal1, na.rm = TRUE), .groups = "drop") |>
  # if goal1 = 0 for any child in household, goal1 is not achieved
  mutate(hh_month_goal1 = if_else(avg_goal1 != 1, 0, 1))


# make lookup tables for fringe cases
# next steps
# bring in household demographic data
# bring in predictor variables
```

# Creating Variables for Achievement of TANF Goal 2

**Goal 2:** End the dependence of needy parents on government benefits by promoting job preparation, work, and marriage.

**Participant Households:** All households who received government benefits in the earliest year of their participation in the study.

**Criteria:** Goal 2 is fulfilled for a participant household if household members are no longer receiving government benefits by the end of the reference frame. Variables related to job preparation, work, and marriage will be used as predictors.

```{r}
#| label: data-for-tanf-goal-2

# find households receiving benefits at beginning of reference period
govt_benefits_begin <- sipp_participants |>
  group_by(sample_unit_id) |>
  # find first year of reference period for household
  filter(year == min(year)) |>
  ungroup() |>
  # detect whether household received benefits
  mutate(govt_benefits_begin = if_else(
    received_ga == 1 | tanf_received_year == 1 | received_snap == 1 | wic_received_year == 1, 1, 0
  )) |>
  # summarize benefit receipt per household
  group_by(year, sample_unit_id) |>
  summarize(govt_benefits_begin = mean(govt_benefits_begin), .groups = "drop") |>
  mutate(govt_benefits_begin = if_else(govt_benefits_begin > 0, 1, 0)) |>
  # save variable for first year of reference period
  rename(begin_year = year)

# find whether households received benefits at end of reference period
govt_benefits_end <- sipp_participants |>
  group_by(sample_unit_id) |>
  # find last year of reference period for household
  filter(year == max(year)) |>
  ungroup() |>
  # detect whethter household received benefits
  mutate(govt_benefits_end = if_else(
    received_ga == 1 | tanf_received_year == 1 | received_snap == 1 | wic_received_year == 1, 1, 0
  )) |>
  # summarize benefit receipt per houeshold
  group_by(year, sample_unit_id) |>
  summarize(govt_benefits_end = mean(govt_benefits_end), .groups = "drop") |>
  mutate(govt_benefits_end = if_else(govt_benefits_end > 0, 1, 0)) |>
  # save variable for last year of reference period
  rename(end_year = year)

# join govt benefits datasets
goal2 <- inner_join(govt_benefits_begin, govt_benefits_end, by = join_by("sample_unit_id")) |>
  # filter for households that are in dataset for more than one year
  # and are receiving government benefits in first year
  filter(begin_year != end_year & govt_benefits_begin == 1) |>
  # create variable for whether the household is still receiving benefits at the end of the reference period
  # 1: goal fulfilled, family is no longer receiving goverment benefits
  # 2: goal not fulfilled
  mutate(goal2 = if_else(govt_benefits_end < govt_benefits_begin, 1, 0)) |>
  mutate(goal2_participant = 1)

# create dataset with relevant variables for tanf goal 2
# didn't feel the need to break this down to the month level
# makes sense to analyze at year level?
# how to evaluate marriage per household? look at if householder is married?
person_goal2 <- sipp_participants |>
  # select relevant variables
  select(sample_unit_id, person_num, age, month, year, reg_salary, has_job, no_job_spell, job_readiness_training, job_training_month, job_search_program, job_skill_training, reading_math_class, work_for_tanf, marital_status, sex) |>
  # create variable for whether individual received job training in month
  # variable for whether the person received job training in the reference period???
  mutate(received_job_training = case_when(
    job_readiness_training == 1 ~ 1,
    job_training_month == 1 ~ 1, 
    job_search_program == 1 ~ 1,
    job_skill_training == 1 ~ 1,
    reading_math_class == 1 ~ 1,
    work_for_tanf == 1 ~ 1,
    .default = 0
  )) |>
  # whether person is married, will look to see whether marriage of householder is  a predictor
  # for goal 2
  mutate(is_married = if_else(marital_status == 1 | marital_status == 2, 1, 0)) |>
  left_join(goal2, join_by(sample_unit_id)) |>
  mutate(goal2_participant = if_else(is.na(goal2_participant), 0, 1))

#count(sipp_tanf, is_married)

```

# Creating Variables for Achievement of TANF Goal 3

**Goal 3:** Prevent and reduce the incidence of out-of-wedlock pregnancies

**Note:** Evaluate at person-level instead of household-level??

**Participants:** Individuals age 15+, for all years in which they are unmarried

**Criteria:** Goal 3 is fulfilled if number of children of an unmarried individual does not increase during reference period (will not catch all cases due to length of pregnancies, abortions, and miscarriages, but should catch most)

```{r}

# limit to women under 45
# look at year by year, someone could get married


goal3 <- sipp_participants |>
  # filter for unmarried women who are 15 or older
  # will only include times at which women are unmarrierd
  filter(age >= 15 & age <= 50 & marital_status != 1 & marital_status != 2 & sex == 2) |>
  # select relevant variables
  select(sample_unit_id, month, year, person_num, num_children) |>
  # convert month and year to date format for easy sorting
  mutate(month = as.character(month)) |>
  mutate(month = if_else(nchar(month) == 1, paste("0", month, sep = ""), month)) |>
  mutate(year_month_day = ymd(paste(year, month, "01", sep = "-"))) |>
  # for each individual, find the earliest and latest dates they are in the sample
  group_by(sample_unit_id, person_num) |>
  mutate(min_date = min(year_month_day), max_date = max(year_month_day)) |>
  ungroup() |>
  # filter for the individuals at their earliest day and latest day
  filter((year_month_day == min_date | year_month_day == max_date)) |>
  # EDIT HERE USE IF ELSE INSTEAD OF WHICH
  group_by(sample_unit_id, person_num) |>
  mutate(is_min_max = if_else(year_month_day == min_date, "is_min_date", "is_max_date")) |>
  #mutate(num_children_min_date = num_children[which(year_month_day == min_date)],
    #     num_children_max_date = num_children[which(year_month_day == max_date)]) |>
  ungroup() |>
  #mutate(children_born = num_children_max_date - num_children_min_date) |>
  distinct() |>
  pivot_wider(
    names_from = "is_min_max",
    values_from = "num_children"
  )
  
  goal3_min <- goal3 |>
    filter(year_month_day == min_date) |>
    select(sample_unit_id, person_num, year_month_day, is_min_date) |>
    distinct() |>
    rename(num_children_start = is_min_date)
  
  goal3_max <- goal3 |>
    filter(year_month_day == max_date) |>
    select(sample_unit_id, person_num, year_month_day, is_max_date) |>
    distinct() |>
    rename(num_children_end = is_max_date)
  
# ???
 goal3 <- goal3 |>
   select(sample_unit_id, person_num) |>
   distinct() |>
   left_join(goal3_min, by = join_by("sample_unit_id", "person_num")) |>
   left_join(goal3_max, by = join_by("sample_unit_id", "person_num")) |>
   select(sample_unit_id, person_num, num_children_start, num_children_end) |>
   mutate(children_born = num_children_end - num_children_start) |>
   filter()
 
 count(goal3, children_born)
 hold <- sipp_participants |>
   filter(age >= 15 & age <= 50 & marital_status != 1 & marital_status != 2 & sex == 2 & childbearing_union == 1) |>
   select(sample_unit_id, person_num, year, num_children) |>
   arrange(sample_unit_id, person_num, year) |>
   distinct()
   
```

```{r}

goal_3_women <- sipp_participants |>
  # filters for women between ages 15 and 50 who are not married
  filter(age >= 15 & age <= 50 & marital_status != 1 & marital_status != 2 & sex == 2) |>
  # select id variables and variables for birth years of children
  select(sample_unit_id, month, year, person_num, num_children, tcbyr_1:tcbyr_7) |>
  # turn year and month into date object
  mutate(month = as.character(month)) |>
  mutate(month = if_else(nchar(month) == 1, paste("0", month, sep = ""), month)) |>
  mutate(year_month_day = ymd(paste(year, month, "01", sep = "-"))) |>
  group_by(sample_unit_id, person_num) |>
  # find minimum and maximum date that each woman is unmarried and in sample
  mutate(min_date = min(year_month_day), max_date = max(year_month_day)) |>
  ungroup() |>
  # create interval based on minimum and maximum date
  mutate(interval = interval(min_date, max_date)) |>
  # pivot data so that each row is the birth year of one of the children of each woman
  pivot_longer(
    cols = starts_with("tcbyr"),
    names_to = "child_indicator",
    values_to = "birth_year"
  ) |>
  # remove observations with no birth year
  filter(!is.na(birth_year)) |>
  # create indicator for whether woman gave birth during time unmarried and in sample
  mutate(had_child_unmarried = if_else(
    birth_year > year(min_date) & birth_year < year(max_date), 1, 0)) |>
  # creates data set of women who had children out-of-wedlock during time in sample
  filter(had_child_unmarried == 1) |>
  select(sample_unit_id, person_num, had_child_unmarried) |>
  distinct()

# checking goal3 indicator with contextual data
# indicator makes sense
goal3_test <- sipp_participants |>
  select(sample_unit_id, person_num, month, year, is_parent, num_children, age, childbearing_union,
         marital_status, unmarried_partner_num, child1_num:child12_num) |>
  right_join(goal_3_women) |>
  arrange(sample_unit_id, person_num, year, month)

# goal 3 participants with indicator for whether goal 3 is fulfilled
# disregards year and month levels
goal3 <- sipp_participants |>
  filter(age >= 15 & age <= 50 & marital_status != 1 & marital_status != 2 & sex == 2) |>
  select(sample_unit_id, person_num) |>
  left_join(goal_3_women, by = join_by(sample_unit_id, person_num)) |>
  mutate(goal3 = if_else(is.na(had_child_unmarried), 1, 0)) |>
  distinct()

goal3 |>
  count(goal3)
```

# Creating Variables for Achievement of TANF Goal 4

**Goal:** Encourage the formation and maintenance of two-parent families.

**Participants:** Households with children and at least one parent

**Criteria:** one parent family is two-parent family at end of reference period, two-parent family is still two-parent family

```{r}

# finds number of parents that each child has for each year and month
child_parent_count <- sipp_participants |>
  # filters participants for children only
  mutate(is_child = if_else(age < 18, 1, 0)) |>
  filter(is_child == 1) |>
  # select relevant variables
  select(sample_unit_id, person_num, age, year, month, parent1_num, parent2_num, parent1_type,
         parent2_type) |>
  # create variable for the number of parents a child has
  mutate(num_parents = case_when(
    is.na(parent1_num) & is.na(parent2_num) ~ 0,
    is.na(parent1_num) | is.na(parent2_num) ~ 1,
    !is.na(parent1_num) & !is.na(parent2_num) ~ 2
  ))

# finds the number of parents recorded for a child at the end of the reference period
child_parent_count_end <- child_parent_count |>
  group_by(sample_unit_id, person_num) |>
  filter(year == max(year)) |> 
  ungroup() |>
  select(sample_unit_id, person_num, year, num_parents) |>
  rename(num_parents_end = num_parents,
         max_year = year) |>
  distinct()

# finds the number of parents recorded for a child at the beginning of the reference period
child_parent_count_start <- child_parent_count |>
  group_by(sample_unit_id, person_num) |>
  filter(year == min(year)) |> 
  ungroup() |>
  select(sample_unit_id, person_num, year, num_parents) |>
  rename(num_parents_start = num_parents,
         min_year = year) |>
  distinct()

# creates indicator for whether a goal is achieved
goal4 <- inner_join(child_parent_count_start, child_parent_count_end,
                    by = join_by("sample_unit_id", "person_num")) |>
  mutate(parent_change = num_parents_end - num_parents_start) |>
  mutate(goal4 = if_else(num_parents_end == 2, 1, 0))

# evaluates whether goal 4 is achieved for a household
hh_goal4 <- goal4 |>
  # group by year, month, and household
  group_by(sample_unit_id) |>
  # determine average (over all children in household in that month)
  # achievement of goal 1
  summarise(avg_goal4 = mean(goal4, na.rm = TRUE), .groups = "drop") |>
  # if goal1 = 0 for any child in household, goal1 is not achieved
  mutate(hh_goal4 = if_else(avg_goal4 != 1, 0, 1))


count(hh_goal4, hh_goal4)
```

# Combine SIPP Data

```{r}


# look at avg for marriage over year

sipp_all_goals <- sipp_participants |>
  # select necessary variables
  select(sample_unit_id, person_num, month, year, age, state, education, ethnicity, race, sex, citizenship, num_children) |>
  # clean up variables 
  mutate(
    education = case_match(
      education,
      31 ~ "Less than 1st grade",
      32 ~ "1st, 2nd, 3rd or 4th grade",
      33 ~ "5th or 6th grade",
      34 ~ "7th or 8th grade",
      35 ~ "9th grade",
      36 ~ "10th grade",
      37 ~ "11th grade",
      38 ~ "12th grade, no diploma",
      39 ~ "High School Graduate",
      40 ~ "Some college credit, but less than 1 year",
      41 ~ "1 or more years of college, no degree",
      42 ~ "Associate's degree",
      43 ~ "Bachelor's degree",
      44 ~ "Master's degree",
      45 ~ "Professional School degree",
      46 ~ "Doctorate degree",
      .default = as.character(education)
    ),
    ethnicity = if_else(ethnicity == 1, "Hispanic", "Not Hispanic"),
    sex = if_else(sex == 1, "Male", "Female"),
    race = case_match(
      race,
      1 ~ "White",
      2 ~ "Black",
      3 ~ "AIAN",
      4 ~ "Asian",
      5 ~ "HP",
      6 ~ "White-Black",
      7 ~ "White-AIAN",
      8 ~ "White-Asian",
      9 ~ "Black-AIAN",
      10 ~ "Other"
    ),
    citizenship = if_else(citizenship == 1, 1, 0)
  ) |>
  # create indicators for whether this person-month is included in the sample for a certain goal
  mutate(
    # all households are in goal 1
    in_goal1 = if_else(sample_unit_id %in% hh_goal1$sample_unit_id, 1, 0),
    in_goal2 = if_else(
    # selected households for goal2
      sample_unit_id %in% goal2$sample_unit_id, 1, 0),
    # all households are in goal 4
    in_goal4 = if_else(sample_unit_id %in% hh_goal4$sample_unit_id, 1, 0)
    ) |>
  # join goal 1 achievement dadta
  left_join(hh_goal1, by = join_by("year", "month", "state", "sample_unit_id")) |>
  select(-(avg_goal1)) |>
  # join goal 2 achievement data
  left_join(person_goal2, by = join_by("sample_unit_id", "person_num", "age", "month", "year")) |>
  # join goal 4 achievement data
  left_join(hh_goal4, by = join_by("sample_unit_id")) |>
  select(-avg_goal4, -sex.y) |>
  rename(goal1 = hh_month_goal1,
         goal4 = hh_goal4,
         sex = sex.x)
```

# Add TANF Data

```{r}

sipp_tanf <- sipp_all_goals |>
  left_join(tanf_state_year, by = join_by("state", "year" == "fiscal_year")) |>
  select(
  # id variables
  sample_unit_id, person_num, month, year,
  # demographics
  age, state, education, ethnicity, race, sex, citizenship, num_children,
  # goal fulfillment indicators
  in_goal1, in_goal2, in_goal4, goal1, goal2, goal4,
  # state-level predictors
  pct_unobligated, pct_program_mgmt, pct_basic_assistance,
  # individual predictors
  received_job_training, is_married)
```

# Add Political Data

I haven't found a dataset yet with information on governors in U.S. states in years 2018 to 2022. I may have to create a table of this information myself.
